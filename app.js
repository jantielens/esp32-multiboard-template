/**
 * ESP32 Multi-Board Template Flasher - Application Logic
 * 
 * This flasher dynamically discovers available boards by:
 * 1. First attempting to load latest.json (generated by CI/CD)
 * 2. Extracting board IDs from the assets array
 * 3. Loading each board's manifest_*.json file
 * 4. Building the board selection UI from manifest metadata
 * 
 * Benefits:
 * - No hardcoded board list - automatically picks up new boards
 * - Board metadata (name, chip family) comes from manifest files
 * - Falls back to common board names if latest.json unavailable
 */

// Board configuration - dynamically loaded
let BOARDS = {};

// Default icons by chip family (fallback if not specified in manifest)
const DEFAULT_ICONS = {
  'ESP32': 'ðŸ“Ÿ',
  'ESP32-S2': 'ðŸ“±',
  'ESP32-S3': 'âš¡',
  'ESP32-C3': 'ðŸ”·',
  'ESP32-C6': 'ðŸ’ ',
  'default': 'ðŸ”§'
};

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
  checkBrowserSupport();
  await loadBoardConfiguration();
  generateDeviceSelection();
});

// Check if browser supports Web Serial API
function checkBrowserSupport() {
  if (!navigator.serial) {
    const warning = document.getElementById('no-support-warning');
    if (warning) {
      warning.classList.remove('hidden');
    }
    console.warn('Web Serial API not supported');
  }
}

// Load board configuration dynamically by discovering manifest files
async function loadBoardConfiguration() {
  try {
    // Get list of manifest files by trying to fetch them
    // We'll discover boards by scanning for manifest_*.json files
    const manifestFiles = await discoverManifests();
    
    for (const manifestFile of manifestFiles) {
      try {
        const response = await fetch(manifestFile);
        if (!response.ok) continue;
        
        const manifest = await response.json();
        const boardId = manifestFile.replace('manifest_', '').replace('.json', '');
        
        // Extract chip family from manifest
        const chipFamily = manifest.builds?.[0]?.chipFamily || 'default';
        
        // Create board entry
        BOARDS[boardId] = {
          name: manifest.name || boardId,
          icon: DEFAULT_ICONS[chipFamily] || DEFAULT_ICONS['default'],
          description: `${chipFamily} board` + (manifest.version ? ` (v${manifest.version})` : ''),
          chipFamily: chipFamily
        };
        
        console.log(`Discovered board: ${boardId} (${chipFamily})`);
      } catch (err) {
        console.warn(`Failed to load manifest ${manifestFile}:`, err);
      }
    }
    
    // If no boards found, show error
    if (Object.keys(BOARDS).length === 0) {
      console.error('No boards discovered');
      showError('No board configurations found. Please check your deployment.');
    }
  } catch (err) {
    console.error('Failed to load board configuration:', err);
    showError('Failed to load board configuration.');
  }
}

// Discover manifest files by checking for common board names
// In production, manifest files are generated by CI/CD pipeline
async function discoverManifests() {
  const manifests = [];
  
  // Try to fetch latest.json first (if available)
  try {
    const response = await fetch('latest.json');
    if (response.ok) {
      const data = await response.json();
      // Extract board IDs from assets
      const boardIds = new Set();
      data.assets?.forEach(asset => {
        if (asset.board) {
          boardIds.add(asset.board);
        }
      });
      
      // Create manifest file names
      boardIds.forEach(boardId => {
        manifests.push(`manifest_${boardId}.json`);
      });
      
      console.log(`Discovered ${manifests.length} boards from latest.json`);
      return manifests;
    }
  } catch (err) {
    console.log('latest.json not available, falling back to direct discovery');
  }
  
  // Fallback: Try common board names
  const commonBoards = [
    'esp32_dev',
    'esp32s2_dev',
    'esp32s3_dev',
    'esp32c3_dev',
    'esp32c6_dev'
  ];
  
  for (const boardId of commonBoards) {
    const manifestPath = `manifest_${boardId}.json`;
    try {
      const response = await fetch(manifestPath, { method: 'HEAD' });
      if (response.ok) {
        manifests.push(manifestPath);
      }
    } catch (err) {
      // Manifest doesn't exist, skip
    }
  }
  
  console.log(`Discovered ${manifests.length} boards via fallback`);
  return manifests;
}

// Show error message to user
function showError(message) {
  const container = document.getElementById('device-selection');
  if (container) {
    container.innerHTML = `<p style="color: var(--error-color); text-align: center; padding: 1rem;">${message}</p>`;
  }
}

// Generate device selection UI
function generateDeviceSelection() {
  const container = document.getElementById('device-selection');
  const installButton = document.querySelector('esp-web-install-button');
  
  if (!container || !installButton) return;

  for (const [boardId, boardInfo] of Object.entries(BOARDS)) {
    const label = document.createElement('label');
    label.className = 'device-option';

    const input = document.createElement('input');
    input.type = 'radio';
    input.name = 'board';
    input.value = boardId;
    input.addEventListener('change', (e) => handleBoardSelection(e, installButton));

    const deviceLabel = document.createElement('span');
    deviceLabel.className = 'device-label';

    const icon = document.createElement('span');
    icon.className = 'device-icon';
    icon.textContent = boardInfo.icon;

    const nameSpan = document.createElement('span');
    nameSpan.className = 'device-name';
    nameSpan.textContent = boardInfo.name;

    const descSpan = document.createElement('span');
    descSpan.className = 'device-desc';
    descSpan.textContent = boardInfo.description;

    deviceLabel.appendChild(icon);
    deviceLabel.appendChild(nameSpan);
    if (boardInfo.description) {
      deviceLabel.appendChild(descSpan);
    }

    label.appendChild(input);
    label.appendChild(deviceLabel);
    container.appendChild(label);
  }

  // Select first board by default
  const firstInput = container.querySelector('input[type="radio"]');
  if (firstInput) {
    firstInput.checked = true;
    handleBoardSelection({ target: firstInput }, installButton);
  }
}

// Handle board selection
function handleBoardSelection(event, installButton) {
  const boardId = event.target.value;
  const manifestPath = `manifest_${boardId}.json`;

  if (installButton) {
    installButton.setAttribute('manifest', manifestPath);
    installButton.classList.remove('hidden');
  }

  console.log(`Selected board: ${boardId}, manifest: ${manifestPath}`);
}
