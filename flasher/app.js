/**
 * ESP32 Multi-Board Template Flasher - Application Logic
 * 
 * This flasher dynamically discovers available boards by:
 * 1. First attempting to load latest.json (generated by CI/CD)
 * 2. Extracting board IDs from the assets array
 * 3. Loading each board's manifest_*.json file
 * 4. Building the board selection UI from manifest metadata
 * 
 * Benefits:
 * - No hardcoded board list - automatically picks up new boards
 * - Board metadata (name, chip family) comes from manifest files
 * - Falls back to common board names if latest.json unavailable
 */

// Project configuration - loaded from config.js (window.PROJECT_CONFIG)
// Fallback defaults if config.js not loaded
let PROJECT_CONFIG = {
  displayName: "ESP32 Multi-Board Template",
  displayNameShort: "ESP32 Template",
  description: "A reusable multi-board template for ESP32 projects with WiFi configuration, MQTT telemetry, deep sleep power management, and OTA updates. Perfect for battery-powered IoT projects, Home Assistant integration, and rapid ESP32 prototyping.",
  repository: "jantielens/esp32-multiboard-template"
};

// Load project configuration from config.js
function loadProjectConfig() {
  if (window.PROJECT_CONFIG) {
    PROJECT_CONFIG = window.PROJECT_CONFIG;
    console.log('Loaded project config from config.js');
  } else {
    console.warn('config.js not loaded, using defaults');
  }
}

// Update page with project configuration
function updateProjectInfo() {
  // Update page title
  document.title = `${PROJECT_CONFIG.displayName} Flasher`;

  // Update meta description
  const metaDesc = document.querySelector('meta[name="description"]');
  if (metaDesc) {
    metaDesc.setAttribute('content', `Flash ${PROJECT_CONFIG.displayName} firmware directly from your browser using Web Serial API`);
  }

  // Update header title
  const headerTitle = document.querySelector('.header-title');
  if (headerTitle) {
    headerTitle.textContent = `âš¡ ${PROJECT_CONFIG.displayName}`;
  }

  // Update GitHub link
  const githubLink = document.querySelector('.header-link');
  if (githubLink && PROJECT_CONFIG.repository) {
    githubLink.href = `https://github.com/${PROJECT_CONFIG.repository}`;
  }

  // Update hero title
  const heroTitle = document.querySelector('.hero-title');
  if (heroTitle) {
    heroTitle.textContent = `${PROJECT_CONFIG.displayName} Firmware Flasher`;
  }

  // Update hero description
  const heroDesc = document.querySelector('.hero-description');
  if (heroDesc) {
    heroDesc.textContent = PROJECT_CONFIG.description;
  }

  // Update install button text
  const installBtn = document.querySelector('.install-btn');
  if (installBtn) {
    installBtn.textContent = `Install ${PROJECT_CONFIG.displayNameShort}`;
  }

  // Update instructions text that mentions the button
  const instructions = document.querySelector('.instructions');
  if (instructions) {
    const buttonMention = instructions.querySelector('strong');
    if (buttonMention && buttonMention.textContent.includes('Install')) {
      buttonMention.textContent = `"Install ${PROJECT_CONFIG.displayNameShort}"`;
    }
  }
}

// Board configuration - dynamically loaded
let BOARDS = {};

// Default icons by chip family (fallback if not specified in manifest)
const DEFAULT_ICONS = {
  'ESP32': 'ðŸ“Ÿ',
  'ESP32-S2': 'ðŸ“±',
  'ESP32-S3': 'âš¡',
  'ESP32-C3': 'ðŸ”·',
  'ESP32-C6': 'ðŸ’ ',
  'default': 'ðŸ”§'
};

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', async () => {
  loadProjectConfig();
  updateProjectInfo();
  checkBrowserSupport();
  await loadBoardConfiguration();
  generateDeviceSelection();
});

// Check if browser supports Web Serial API
function checkBrowserSupport() {
  if (!navigator.serial) {
    const warning = document.getElementById('no-support-warning');
    if (warning) {
      warning.classList.remove('hidden');
    }
    console.warn('Web Serial API not supported');
  }
}

// Load board configuration dynamically by discovering manifest files
async function loadBoardConfiguration() {
  try {
    // Get list of manifest files by trying to fetch them
    // We'll discover boards by scanning for manifest_*.json files
    const manifestFiles = await discoverManifests();
    
    for (const manifestFile of manifestFiles) {
      try {
        const response = await fetch(manifestFile);
        if (!response.ok) continue;
        
        const manifest = await response.json();
        const boardId = manifestFile.replace('manifest_', '').replace('.json', '');
        
        // Extract chip family from manifest
        const chipFamily = manifest.builds?.[0]?.chipFamily || 'default';
        
        // Create board entry
        BOARDS[boardId] = {
          name: manifest.name || boardId,
          icon: DEFAULT_ICONS[chipFamily] || DEFAULT_ICONS['default'],
          description: `${chipFamily} board` + (manifest.version ? ` (v${manifest.version})` : ''),
          chipFamily: chipFamily
        };
        
        console.log(`Discovered board: ${boardId} (${chipFamily})`);
      } catch (err) {
        console.warn(`Failed to load manifest ${manifestFile}:`, err);
      }
    }
    
    // If no boards found, show error
    if (Object.keys(BOARDS).length === 0) {
      console.error('No boards discovered');
      showError('No board configurations found. Please check your deployment.');
    }
  } catch (err) {
    console.error('Failed to load board configuration:', err);
    showError('Failed to load board configuration.');
  }
}

// Discover manifest files by checking for common board names
// In production, manifest files are generated by CI/CD pipeline
async function discoverManifests() {
  const manifests = [];
  
  // Try to fetch latest.json first (if available)
  try {
    const response = await fetch('latest.json');
    if (response.ok) {
      const data = await response.json();
      // Extract board IDs from assets
      const boardIds = new Set();
      data.assets?.forEach(asset => {
        if (asset.board) {
          boardIds.add(asset.board);
        }
      });
      
      // Create manifest file names
      boardIds.forEach(boardId => {
        manifests.push(`manifest_${boardId}.json`);
      });
      
      console.log(`Discovered ${manifests.length} boards from latest.json`);
      return manifests;
    }
  } catch (err) {
    console.log('latest.json not available, falling back to direct discovery');
  }
  
  // Fallback: Try common board names
  const commonBoards = [
    'esp32_dev',
    'esp32s2_dev',
    'esp32s3_dev',
    'esp32c3_dev',
    'esp32c6_dev'
  ];
  
  for (const boardId of commonBoards) {
    const manifestPath = `manifest_${boardId}.json`;
    try {
      const response = await fetch(manifestPath, { method: 'HEAD' });
      if (response.ok) {
        manifests.push(manifestPath);
      }
    } catch (err) {
      // Manifest doesn't exist, skip
    }
  }
  
  console.log(`Discovered ${manifests.length} boards via fallback`);
  return manifests;
}

// Show error message to user
function showError(message) {
  const container = document.getElementById('device-selection');
  if (container) {
    container.innerHTML = `<p style="color: var(--error-color); text-align: center; padding: 1rem;">${message}</p>`;
  }
}

// Generate device selection UI
function generateDeviceSelection() {
  const container = document.getElementById('device-selection');
  const installButton = document.querySelector('esp-web-install-button');
  
  if (!container || !installButton) return;

  for (const [boardId, boardInfo] of Object.entries(BOARDS)) {
    const label = document.createElement('label');
    label.className = 'device-option';

    const input = document.createElement('input');
    input.type = 'radio';
    input.name = 'board';
    input.value = boardId;
    input.addEventListener('change', (e) => handleBoardSelection(e, installButton));

    const deviceLabel = document.createElement('span');
    deviceLabel.className = 'device-label';

    const icon = document.createElement('span');
    icon.className = 'device-icon';
    icon.textContent = boardInfo.icon;

    const nameSpan = document.createElement('span');
    nameSpan.className = 'device-name';
    nameSpan.textContent = boardInfo.name;

    const descSpan = document.createElement('span');
    descSpan.className = 'device-desc';
    descSpan.textContent = boardInfo.description;

    deviceLabel.appendChild(icon);
    deviceLabel.appendChild(nameSpan);
    if (boardInfo.description) {
      deviceLabel.appendChild(descSpan);
    }

    label.appendChild(input);
    label.appendChild(deviceLabel);
    container.appendChild(label);
  }

  // Select first board by default
  const firstInput = container.querySelector('input[type="radio"]');
  if (firstInput) {
    firstInput.checked = true;
    handleBoardSelection({ target: firstInput }, installButton);
  }
}

// Handle board selection
function handleBoardSelection(event, installButton) {
  const boardId = event.target.value;
  const manifestPath = `manifest_${boardId}.json`;

  if (installButton) {
    installButton.setAttribute('manifest', manifestPath);
    installButton.classList.remove('hidden');
  }

  console.log(`Selected board: ${boardId}, manifest: ${manifestPath}`);
}
